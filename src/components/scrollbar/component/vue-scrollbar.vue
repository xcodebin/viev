<template>
    <div
            :class="'vue-scrollbar__wrapper' + ( this.classes ? ' ' + this.classes : '' )"
            ref="scrollWrapper"
            @wheel="scroll"
            :style="this.styles">

        <div
                :class="'vue-scrollbar__area' + ( this.dragging ? ' ' : ' vue-scrollbar-transition')"
                ref="scrollArea"
                @touchstart="startDrag"
                @touchmove="onDrag"
                @touchend="stopDrag"
                :style="{
        marginTop: this.top * -1 +'px',
        marginLeft: this.left * -1 +'px'
      }">
            <div ref="watchArea" :style="this.styles">
                <slot></slot>
            </div>
            <vertical-scrollbar
                    v-if="ready && !nover"
                    :area="scrollAreaHeight"
                    :wrapper="scrollWrapperHeight"
                    :scrolling="vMovement"
                    :dragging-from-parent="dragging"
                    :on-change-position="handleChangePosition"
                    :on-dragging="handleScrollbarDragging"
                    :on-stop-drag="handleScrollbarStopDrag">
            </vertical-scrollbar>

            <horizontal-scrollbar
                    v-if="ready && !nohor"
                    :area="scrollAreaWidth"
                    :wrapper="scrollWrapperWidth"
                    :scrolling="hMovement"
                    :dragging-from-parent="dragging"
                    :on-change-position="handleChangePosition"
                    :on-dragging="handleScrollbarDragging"
                    :on-stop-drag="handleScrollbarStopDrag">
            </horizontal-scrollbar>
        </div>

    </div>

</template>


<script>

    import VerticalScrollbar from './vertical-scrollbar.vue';
    import HorizontalScrollbar from './horizontal-scrollbar.vue';
    import Clay from '../../../utils/clay';

    export default {

        props: {
            classes: String,
            styles: Object,
            speed: {
                type: Number,
                default: 53
            },
            nover: {
                type: Boolean,
                default: false
            },
            nohor: {
                type: Boolean,
                default: false
            }
        },
        components: {
            VerticalScrollbar,
            HorizontalScrollbar
        },
        data () {
            return {
                ready: false,
                state: false,
                top: 0,
                left: 0,
                end: 0,
                scrollAreaHeight: null,
                scrollAreaWidth: null,
                scrollWrapperHeight: null,
                scrollWrapperWidth: null,
                vMovement: 0,
                hMovement: 0,
                dragging: false,
                start: {y: 0, x: 0},
                sWidth: 3,
                sHeight: 0,
                watchareaWidth: '100%'
            };
        },
        methods: {
            scroll(e){
                let elementSize = this.getSize();

                elementSize.scrollAreaHeight - elementSize.scrollWrapperHeight <= 0 ? this.state = false : this.state = true;

                if (this.state) {
                    e.preventDefault();
                    e.stopPropagation();//注销这里可以冒泡
                }

                // Make sure the content height is not changed
                this.calculateSize(() => {
                    // Set the wheel step
                    let num = this.speed;

                    // DOM events
                    let shifted = e.shiftKey;
                    let scrollY = e.deltaY > 0 ? num : -(num);
                    let scrollX = e.deltaX > 0 ? num : -(num);
                    // Fix Mozilla Shifted Wheel~
                    if (shifted && e.deltaX == 0) scrollX = e.deltaY > 0 ? num : -(num);

                    // Next Value
                    let nextY = this.top + scrollY;
                    let nextX = this.left + scrollX;

                    // Is it Scrollable?
                    let canScrollY = this.scrollAreaHeight > this.scrollWrapperHeight;
                    let canScrollX = this.scrollAreaWidth > this.scrollWrapperWidth;

                    // Vertical Scrolling
                    if (canScrollY && !shifted) this.normalizeVertical(nextY);

                    // Horizontal Scrolling
                    if (!shifted && canScrollX) this.normalizeHorizontal(nextX);
                });
                if (this.top >= this.end) {
                    this.$emit('scrollToEnd', this.end);
                }
                this.$emit('scroll', this.top);

            },

            // DRAG EVENT JUST FOR TOUCH DEVICE~
            startDrag(e){
                e.preventDefault();
                e.stopPropagation();

                e = e.changedTouches ? e.changedTouches[0] : e;

                // Make sure the content height is not changed
                this.calculateSize(() => {
                    // Prepare to drag
                    this.dragging = true;
                    this.start = {y: e.pageY, x: e.pageX};
                });

            },

            onDrag(e){
                if (this.dragging) {

                    e.preventDefault();
                    e = e.changedTouches ? e.changedTouches[0] : e;

                    // Invers the Movement
                    let yMovement = this.start.y - e.clientY;
                    let xMovement = this.start.x - e.clientX;

                    // Update the last e.client
                    this.start = {y: e.clientY, x: e.clientX};

                    // The next Vertical Value will be
                    let nextY = this.top + yMovement;
                    let nextX = this.left + xMovement;

                    this.normalizeVertical(nextY);
                    this.normalizeHorizontal(nextX);

                }
            },

            stopDrag(){
                this.dragging = false;
            },

            scrollToY(y) {
                this.normalizeVertical(y);
            },

            scrollToX(x) {
                this.normalizeHorizontal(x);
            },

            scrollAddY(y) {
                this.normalizeVertical(this.top + y);
            },

            scrollAddX(x) {
                this.normalizeHorizontal(this.left + x);
            },

            scrollToEnd(y) {
                if (y) {
                    this.normalizeVertical(this.end + y);
                } else {
                    this.normalizeVertical(this.end);
                }
            },

            normalizeVertical(next){
                let elementSize = this.getSize();

                // Vertical Scrolling
                let lowerEnd = elementSize.scrollAreaHeight - elementSize.scrollWrapperHeight;

                // Max Scroll Down
                if (next > lowerEnd) next = lowerEnd;

                // Max Scroll Up
                else if (next < 0) next = 0;

                // Update the Vertical Value
                this.top = next;
                this.vMovement = next / elementSize.scrollAreaHeight * 100;
                this.$emit('verticalScr', this.top);
            },

            normalizeHorizontal(next){
                let elementSize = this.getSize();

                // Horizontal Scrolling
                let rightEnd = elementSize.scrollAreaWidth - this.scrollWrapperWidth;

                // Max Scroll Right
                if (next > rightEnd) next = rightEnd;

                // Max Scroll Right
                else if (next < 0) next = 0;

                // Update the Horizontal Value
                this.left = next;
                this.hMovement = next / elementSize.scrollAreaWidth * 100;
                this.$emit('horizontalScr', this.left);
            },

            handleChangePosition(movement, orientation){
                // Make sure the content height is not changed
                this.calculateSize(() => {
                    // Convert Percentage to Pixel
                    let next = movement / 100;
                    if (orientation == 'vertical') this.normalizeVertical(next * this.scrollAreaHeight);
                    if (orientation == 'horizontal') this.normalizeHorizontal(next * this.scrollAreaWidth);
                });
            },

            handleScrollbarDragging(){
                this.dragging = true;
            },

            handleScrollbarStopDrag(){
                this.dragging = false;
            },

            getSize(){
                // The Elements
                let $scrollArea = this.$refs.watchArea;
                let $scrollWrapper = this.$refs.scrollWrapper;
                // Get new Elements Size
                let elementSize = {
                    // Scroll Area Height and Width
                    scrollAreaHeight: $scrollArea.children[0].clientHeight,
                    scrollAreaWidth: $scrollArea.children[0].clientWidth,

                    // Scroll Wrapper Height and Width
                    scrollWrapperHeight: $scrollWrapper.clientHeight,
                    scrollWrapperWidth: $scrollWrapper.clientWidth,
                };
                return elementSize;
            },

            calculateSize(cb){
                if (typeof cb !== 'function') cb = null;

                let elementSize = this.getSize();

                this.end = elementSize.scrollAreaHeight - elementSize.scrollWrapperHeight;

                if (elementSize.scrollWrapperHeight !== this.scrollWrapperHeight ||
                    elementSize.scrollWrapperWidth !== this.scrollWrapperWidth ||
                    elementSize.scrollAreaHeight !== this.scrollAreaHeight ||
                    elementSize.scrollAreaWidth !== this.scrollAreaWidth) {

                    // Scroll Area Height and Width
                    this.scrollAreaHeight = elementSize.scrollAreaHeight;
                    this.scrollAreaWidth = elementSize.scrollAreaWidth;

                    // Scroll Wrapper Height and Width
                    this.scrollWrapperHeight = elementSize.scrollWrapperHeight;
                    this.scrollWrapperWidth = elementSize.scrollWrapperWidth;
                    if (this.scrollAreaHeight < this.scrollWrapperHeight) {
                        this.top = 0;
                        this.vMovement = 0;
                    }
                    if (this.scrollAreaWidth < this.scrollWrapperWidth) {
                        this.left = 0;
                        this.hMovement = 0;
                    }
                    // Make sure The wrapper is Ready, then render the scrollbar
                    this.ready = true;

                    return cb ? cb(elementSize) : false;
                }

                else return cb ? cb(elementSize) : false;
            },

            reset(){
                this.top = 0;
                this.left = 0;
                this.vMovement = 0;
                this.hMovement = 0;
            }
        },

        mounted () {
            this.$nextTick(() => {
                if (document.getElementsByClassName('vue-scrollbar__scrollbar-vertical') && document.getElementsByClassName('vue-scrollbar__scrollbar-vertical').length > 0) {
                    this.sWidth = document.getElementsByClassName('vue-scrollbar__scrollbar-vertical')[0].offsetWidth;//动态获取滚动条宽度
                }
            });
            let ele = new Clay(this.$refs.watchArea);
            ele.on('resize', () => {
                this.calculateSize();
            });
            this.calculateSize();

            // Attach The Event for Responsive View~
            window.addEventListener('resize', this.calculateSize);
        },
        beforeDestroy (){
            // Remove Event
            window.removeEventListener('resize', this.calculateSize);
        }

    };

</script>
